---
layout: post
title:  "(RDBMS) --> (graph)"
date:   2014-07-21 19:26:00
categories: RDBMS graph
---

# Acerca
Buscando probar un base de datos NoSQL, más precisamente una base de grafos como es [Neo4j][neo4j], me di cuenta que no tenia datos para hacerlo.
En verdad si, podía jugar con [cypher][neo4j sample db] pero quería ver como _acomodar_ una base de datos relacional en este nuevo esquema.
Para esto me propuse **migrar** la base de datos [sakila][mysql sakila], pasarla de un esquema relacional a uno de grafos.
comenzando por las tablas y relaciones y continuar con las vistas.

----

## Plan
Los pasos que tengo que realizar son:
### Metadata
Analizar la estructura del modelo relacional, el de grafos y sus las similitudes

1. Entender los patrones básicos de los grafos para poder traducir las tablas y sus relaciones (FK -> PK). 
2. Migrar la estructura de la base relacional, **no los datos**. para tener un esquema base e ir probando diferentes cosas.
3. Ver esta estructura en un gráfico.

{% plantuml %}

skinparam monochrome true

Alice -> Bob: Authentication Request
Bob --> Alice: Authentication Response

Alice -> Bob: Another authentication Request
Alice <-- Bob: another authentication Response
{% endplantuml %}

**Graph demo**

{% plantuml %}
	skinparam usecaseBackgroundColor DarkSeaGreen
	skinparam usecaseArrowColor Olive
	skinparam actorBorderColor black
	skinparam usecaseBorderColor DarkSlateGray
	skinparam usecaseActorFontName Courier
	
	User << Human >>
	:Main Database: as MySql << Application >>
	(Start) << One Shot >>
	(Use the application) as (Use) << Main >>
	User -> (Start)
	User --> (Use)
	MySql --> (Use)
{% endplantuml%}

{% plantuml %}

skinparam monochrome true
() actor as Ac
() film as Fi
() alq as Al
Ac -- Fi
Fi -- Al
Al --> Ac

{% endplantuml%}     que bueno esta esto       {% plantuml %}
left to right direction
skinparam monochrome true

object film {
   **film_id**
   name
   date
}

object film_has_actor {
   **film_id**
   **actor_id**
   role
}

object actor {
  **actor_id**
   name
   date
}

film <-- film_has_actor
film_has_actor --> actor
	
{% endplantuml%}

**DBMetadata class diagram**

{% plantuml %}
skinparam monochrome true

	DBObject <|-- DBTable
	DBObject <|-- DBColumn
	DBObject <|-- DBPrimaryKey
	DBObject <|-- DBForeignKey

	DBTable "1" *-- "many" DBColumn
	DBTable -- DBPrimaryKey
	DBPrimaryKey "1..*" o-- "1" DBColumn
	DBPrimaryKey o-- DBForeignKey

{% endplantuml%}


### Definir la estructura a migrar
En una primera instancia voy a migrar la base completa, por cada tupla genero un nodo, por cada _foreign key_ en una tabla, una relación en la nueva base

### Optimizar la migración

En una primera instancia voy a migrar la base completa, por cada tupla genero un nodo, por cada _foreign key_ en una tabla, una relación en la nueva base

# Genera archivos
En una primera instancia voy a migrar la base completa, por cada tupla genero un nodo, por cada _foreign key_ en una tabla, una relación en la nueva base

## Archivos Cypher
En una primera instancia voy a migrar la base completa, por cada tupla genero un nodo, por cada _foreign key_ en una tabla, una relación en la nueva base

### JavaBeans
En una primera instancia voy a migrar la base completa, por cada tupla genero un nodo, por cada _foreign key_ en una tabla, una relación en la nueva base

### etc
En una primera instancia voy a migrar la base completa, por cada tupla genero un nodo, por cada _foreign key_ en una tabla, una relación en la nueva base


# BatchImport
En una primera instancia voy a migrar la base completa, por cada tupla genero un nodo, por cada _foreign key_ en una tabla, una relación en la nueva base

## Metadata en Neo4J
En una primera instancia voy a migrar la base completa, por cada tupla genero un nodo, por cada _foreign key_ en una tabla, una relación en la nueva base

## Datos de la base relacional
En una primera instancia voy a migrar la base completa, por cada tupla genero un nodo, por cada _foreign key_ en una tabla, una relación en la nueva base

{% plantuml %}
skinparam monochrome true
actor User
participant R2G as r2g
participant DAOFactory as f
participant TemplateBuilder as t


User -> r2g : process

r2g -> f : connect
f --> r2g : c : connection

r2g -> t : writeTemplate(tables)



{% endplantuml %}

# Depura relaciones de grafos


# Procesar JDBC Metadata

Que es una base de datos relacional?
Bueno es esto [mysql][mysql]
Para poder leer esta estructura utilizo las apis [jdbc][api jdbc] de java, primero leo de [java.sql.ResultSet][api ResultSet]


# Procesa JDBC Metadata

## Carga de objetos

Tabla1 | tabla1_has_tabla2| Tabla2
-----|---|---
film|film_has_actor|actor
film|film_has_actor|actor
film|film_has_actor|actor






  [1]: http://adarraidou.files.wordpress.com/2009/08/tpersonas.jpg?w=595
  [mysql]: http://dev.mysql.com/doc/index-other.html
  [mysql sakila]: http://dev.mysql.com/doc/sakila/en/
  [api jdbc]: http://docs.oracle.com/javase/7/docs/technotes/guides/jdbc/
  [api ResultSet]: http://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html
  [api DatabaseMetaData]: http://docs.oracle.com/javase/7/docs/api/java/sql/DatabaseMetaData.html
  [neo4j]: http://neo4j.com
  [neo4j sample db]: http://docs.neo4j.org/chunked/stable/cypherdoc-movie-database.html
  [groovy]: http://groovy.codehaus.org/
  
  
